# 事件循环

## 进程

事件循环是跟**浏览器**密切相关的。

**进程**：程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程。

每个应用至少有一个进程，进程之间**相互独立**（一个进程崩溃不会影响到别的进程），即使要通信，也需要双方同意。

:::details
![](/images/browser/EventLoop/01.png)
:::

## 线程

有了进程后，就可以运行程序的代码了。

运行代码的“人”称之为“线程”。

一个进程至少有一个线程，所以进程开启后会自动创建一个线程来运行代码，改线程称之为主线程。

如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。

主线程结束了就代表程序结束。

:::details
![](/images/browser/EventLoop/02.png)
:::

## 浏览器

浏览器是一个多进程多线程的应用程序。

为了避免相互影响，减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。

1. 浏览器进程

   主要负责界面显示（标签页样式，后退前进按钮等）、用户交互（用户在浏览器窗口点击，鼠标滚动，键盘点击，监听等）、子进程管理（网络进程，渲染进程等）等。浏览器进程内部会启动多个线程处理不同的任务。

2. 网络进程

   负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。

3. **渲染进程**

   渲染进程启动后，会开启一个**渲染主线程**，主要负责执行 HTML、CSS、JS 代码。
   默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。

:::details
![](/images/browser/EventLoop/03.png)
:::

## 渲染主线程

渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：

- 解析 HTML
- 解析 CSS
- 计算样式
- 布局
- 处理图层
- 每秒把页面画 60 次
- 执行全局 JS 代码
- 执行事件处理函数
- 执行计时器的回调函数
- ......

渲染主线程**调度任务**的方式：排队

:::details
![](/images/browser/EventLoop/04.png)
:::

1. 在最开始的时候，渲染主线程会进入一个无限循环。

2. 每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入循环；如果没有，则进入休眠状态。

3. 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务。

这样一来，就可以让每个任务有条不紊、持续的进行下去了。

整个过程，被称之为事件循环（消息循环）。

## 异步

**异步**：代码在执行过程中，会遇到一些无法立即处理的任务，比如：

- 计时完成后需要执行的任务 -- `setTimeout`、`setInterval`

- 网络通信完成后需要执行的任务 -- `XHR`、`Fetch`

- 用户操作后需要执行的任务 -- `addEventListener`

如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于“阻塞”的状态，从而导致浏览器“卡死”。

:::details
![](/images/browser/EventLoop/05.png)
:::

渲染主线程承担着极其重要的工作，无论如何都不能阻塞。

:::details
![](/images/browser/EventLoop/06.png)
![](/images/browser/EventLoop/07.png)
:::

## 消息队列

任务没有优先级，在消息队列中先进先出。

但消息队列是有优先级的。

- 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。

- 浏览器必须准备好一个微队列，微队列中的任务有限所有其他任务执行。

在目前 chrome 的实现中，至少包含了下面的队列：

- 延时队列：用于存放计时器到达后的回调任务，优先级中；

- 交互队列：用于存放用户操作后产生的事件处理任务，优先级高；

- 微队列：用户存放需要最快执行的任务，优先级最高（`Promise`、`MutationObserver`）；

::: tip
单线程是异步产生的原因

事件循环时异步的实现方式
:::

:::details
![](/images/browser/EventLoop/08.png)
:::
